#!/usr/bin/env python3
"""
generate_from_name.py

Uso:
  python3 generate_from_name.py <LibraryName>

Exemplo:
  python3 generate_from_name.py Servo

Isso criará (se ainda não existirem):
  include/arduino_servo.h
  src/arduino_servo.c
  tests/test_servo_ok.c
  tests/test_servo_bad.c

O script contém templates para várias bibliotecas Arduino comuns. Para bibliotecas
não mapeadas ele criará um esqueleto que INFELIZMENTE, você deverá completar (por enquanto).
"""
import os, sys, textwrap, re

# --- CONFIG: templates por biblioteca (heurísticas e protótipos) ---
LIB_TEMPLATES = {
    "core": {
        "prototypes": [
            ("void", "pinMode", "int pin, int mode"),
            ("void", "digitalWrite", "int pin, int val"),
            ("int", "digitalRead", "int pin")
        ],
        "notes": "Modelos básicos para operações digitais (pinMode/digitalRead/digitalWrite)."
    },
    "analog": {
        "prototypes": [
            ("int", "analogRead", "int pin"),
            ("void", "analogWrite", "int pin, int value")
        ],
        "notes": "Leituras analógicas (0..1023)."
    },
    "time": {
        "prototypes": [
            ("unsigned long", "millis", "void"),
            ("void", "delay", "unsigned long ms")
        ],
        "notes": "Temporização básica."
    },
    "serial": {
        "prototypes": [
            ("void", "Serial_begin", "long baud"),
            ("void", "Serial_print", "const char *s")
        ],
        "notes": "Serial minimal (modelado por funções nomeadas)."
    },
    "wire": {
        "prototypes": [
            ("void", "Wire_begin", "void"),
            ("size_t", "Wire_write", "int addr, const char *buf, size_t len"),
            ("int", "Wire_read", "int addr")
        ],
        "notes": "I2C (Wire)."
    },
    "spi": {
        "prototypes": [
            ("void", "SPI_begin", "void"),
            ("uint8_t", "SPI_transfer", "uint8_t data")
        ],
        "notes": "SPI básico (transfer retorna byte)."
    },
    "eeprom": {
        "prototypes": [
            ("uint8_t", "EEPROM_read", "int address"),
            ("void", "EEPROM_write", "int address, uint8_t value")
        ],
        "notes": "EEPROM read/write."
    },
    "ethernet": {
        "prototypes": [
            ("int", "Ethernet_begin", "void"),
            ("int", "Ethernet_available", "void"),
            ("int", "Ethernet_read", "void")
        ],
        "notes": "Ethernet - protótipos simplificados."
    },
    "liquidcrystal": {
        "prototypes": [
            ("void", "LiquidCrystal_begin", "int cols, int rows"),
            ("void", "LiquidCrystal_print", "const char *s"),
            ("void", "LiquidCrystal_setCursor", "int col, int row")
        ],
        "notes": "Display LCD (LiquidCrystal)."
    },
    "servo": {
        "prototypes": [
            ("void", "Servo_attach", "int pin"),
            ("void", "Servo_write", "int angle"),
            ("int", "Servo_read", "void")
        ],
        "notes": "Servo minimal (attach/write/read)."
    }
}

# --- Helpers ---
def sanitize(name):
    # keep only alnum and underscore, lowercase
    s = re.sub(r'[^0-9a-zA-Z_]', '_', name)
    return s.lower()

def ensure_dirs():
    os.makedirs("include", exist_ok=True)
    os.makedirs("src", exist_ok=True)
    os.makedirs("tests", exist_ok=True)

def make_header(libfile, libname, prototypes, notes):
    guard = f"_{libfile.upper()}_H_"
    lines = []
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append('')
    lines.append('#include <esbmc.h>')
    lines.append('/* Operational model header generated by generate_from_name.py */')
    if notes:
        lines.append(f"/* Notes: {notes} */")
    lines.append('')
    for ret, name, params in prototypes:
        lines.append(f"{ret} {name}({params});")
    lines.append('')
    lines.append("#endif")
    return "\n".join(lines)

def infer_checks_from_param(param_name):
    ln = param_name.lower()
    if "pin" in ln:
        return "(pin >= 0 && pin <= 13)"  # UNO default
    if "addr" in ln or "address" in ln:
        return "(address >= 0)"
    if "angle" in ln:
        return "(angle >= 0 && angle <= 180)"
    if "value" in ln or "val" in ln:
        return "(value >= 0)"
    return None

def make_src(libfile, libname, prototypes):
    lines = []
    lines.append(f'#include "{libfile}.h"')
    lines.append('')
    for ret, fname, params in prototypes:
        lines.append(f"{ret} {fname}({params}) {{")
        # try to get param names to produce checks
        param_names = []
        if params.strip() and params.strip().lower() != "void":
            parts = [p.strip() for p in params.split(",") if p.strip()]
            for p in parts:
                # last token usually name
                tok = p.split()[-1]
                param_names.append(tok)
        # add asserts for first relevant param
        for pn in param_names:
            chk = infer_checks_from_param(pn)
            if chk:
                # use message that includes function name
                lines.append(f'    __ESBMC_assert({chk}, "{fname}: precondition failed on {pn}");')
        # return model if non-void
        if "void" not in ret:
            # simple heuristics
            if "read" in fname.lower() or "available" in fname.lower():
                lines.append(f'    {ret} __ret = 0;')
                if "digital" in fname.lower():
                    lines.append('    __ESBMC_assume(__ret == 0 || __ret == 1);')
                else:
                    lines.append('    __ESBMC_assume(__ret >= 0);')
                lines.append('    return __ret;')
            elif "millis" in fname.lower() or "micros" in fname.lower():
                lines.append(f'    {ret} __ret = 0;')
                lines.append('    __ESBMC_assume(__ret >= 0);')
                lines.append('    return __ret;')
            else:
                lines.append(f'    {ret} __ret = 0;')
                lines.append('    /* unconstrained return value (adjust heuristics if needed) */')
                lines.append('    return __ret;')
        else:
            lines.append('    /* noop model */')
        lines.append('}')
        lines.append('')
    return "\n".join(lines)

def make_test_ok(libfile, libname, prototypes):
    lines = []
    lines.append(f'#include "{libfile}.h"')
    lines.append('')
    lines.append('int main() {')
    lines.append('    int pin = 2;')
    for ret, fname, params in prototypes:
        # build safe arg list
        args = []
        if params.strip() and params.strip().lower() != "void":
            parts = [p.strip() for p in params.split(",") if p.strip()]
            for p in parts:
                pname = p.split()[-1]
                if "pin" in pname.lower():
                    args.append('pin')
                elif "angle" in pname.lower():
                    args.append('90')
                elif "value" in pname.lower() or "val" in pname.lower():
                    args.append('512')
                elif "address" in pname.lower() or "addr" in pname.lower():
                    args.append('0')
                elif "const char" in p.lower():
                    args.append('"ok"')
                else:
                    args.append('0')
        argstr = ", ".join(args)
        if "void" not in ret:
            lines.append(f'    {ret} r_{fname} = {fname}({argstr});')
        else:
            lines.append(f'    {fname}({argstr});')
    lines.append('    return 0;')
    lines.append('}')
    return "\n".join(lines)

def make_test_bad(libfile, libname, prototypes):
    lines = []
    lines.append(f'#include "{libfile}.h"')
    lines.append('')
    lines.append('int main() {')
    lines.append('    int pin = 99; /* intentionally invalid to trigger precondition */')
    for ret, fname, params in prototypes:
        args = []
        if params.strip() and params.strip().lower() != "void":
            parts = [p.strip() for p in params.split(",") if p.strip()]
            for p in parts:
                pname = p.split()[-1]
                if "pin" in pname.lower():
                    args.append('pin')
                elif "angle" in pname.lower():
                    args.append('999')
                elif "value" in pname.lower() or "val" in pname.lower():
                    args.append('9999')
                elif "address" in pname.lower() or "addr" in pname.lower():
                    args.append('-1')
                elif "const char" in p.lower():
                    args.append('"bad"')
                else:
                    args.append('0')
        argstr = ", ".join(args)
        if "void" not in ret:
            lines.append(f'    {ret} r_{fname} = {fname}({argstr});')
            lines.append('    __ESBMC_assert(0, "force fail to show counterexample");')
        else:
            lines.append(f'    {fname}({argstr});')
            lines.append('    __ESBMC_assert(0, "force fail to show counterexample");')
    lines.append('    return 0;')
    lines.append('}')
    return "\n".join(lines)

# --- Main ---
def main():
    if len(sys.argv) < 2:
        print("Usage: python3 generate_from_name.py <LibraryName>")
        sys.exit(1)
    rawname = sys.argv[1]
    libkey = sanitize(rawname)
    if libkey.startswith("arduino_"):
        libkey = libkey[len("arduino_"):]
    # if exists in templates use it, else stub
    if libkey in LIB_TEMPLATES:
        template = LIB_TEMPLATES[libkey]
        prototypes = template["prototypes"]
        notes = template.get("notes", "")
    else:
        # generic stub: create a couple of common prototypes
        prototypes = [
            ("void", f"{rawname}_init", "void"),
            ("int", f"{rawname}_do", "int param")
        ]
        notes = "Skeleton generated: please edit prototypes to match the real library API."
    libfile = f"arduino_{libkey}"
    # ensure dirs
    ensure_dirs()
    # create header
    header_path = os.path.join("include", f"{libfile}.h")
    src_path = os.path.join("src", f"{libfile}.c")
    test_ok_path = os.path.join("tests", f"test_{libkey}_ok.c")
    test_bad_path = os.path.join("tests", f"test_{libkey}_bad.c")
    # write files (avoid overwriting unless user confirms? we'll overwrite if not exists)
    def write_if_not_exists(path, content):
        if os.path.exists(path):
            print(f"[skipping existing] {path} (already exists)")
            return
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"[created] {path}")
    header_content = make_header(libfile, libkey, prototypes, notes)
    src_content = make_src(libfile, libkey, prototypes)
    test_ok_content = make_test_ok(libfile, libkey, prototypes)
    test_bad_content = make_test_bad(libfile, libkey, prototypes)
    write_if_not_exists(header_path, header_content)
    write_if_not_exists(src_path, src_content)
    write_if_not_exists(test_ok_path, test_ok_content)
    write_if_not_exists(test_bad_path, test_bad_content)
    print("")
    print("Pronto. Arquivos gerados (ou existentes mostrados).")
    print("Para verificar com ESBMC (exemplo):")
    print(f"  esbmc {test_ok_path} {src_path} -Iinclude --unwind 5")
    print(f"  esbmc {test_bad_path} {src_path} -Iinclude --unwind 5")
    print("Se sua stub depende de outros OMs (ex.: pinMode em arduino_core), inclua também src/arduino_core.c no comando.")

if __name__ == "__main__":
    main()
